# 深入理解计算机系统

## 数据表示

### 信息的存储

- 现在的计算机基本都是按照byte来寻址的，每一个byte都有一个地址

- 熟悉16进制的表示：A-10，C-12，F-15。0x开头

- 字长：指明指针数据的标称大小，若一个字长为w位的机器，虚拟地址为$0-2^w-1$，地址总线的根数

- 程序是32位还是64位的取决于，编译器如何编译这个程序，e.g. $gcc -m64\quad prog.c$ or $gcc -m32 \quad prog.c$

- 某个基本数据类型的大小具体是多少也得看编译器

- little endian：一个程序对象有$w$位(为8的整数倍)，此时这个程序对象可以几个字节来表示，如果高位存在高地址，低位存在低地址那么称为小端法存储。big endian：与小端法相反，先表示为位级，然后高位存在低地址，低位存在高地址。

  例如：0x01234567的起始地址为0x100，正常表示中左边是高位，右边是低位

  大端法为 0x100~0x103中存储的为 01 23 45 67

  小端法为 0x100~0x103中存储的为  67 45 23 01

  大端小端法的问题一般在三种情况下出现：1 网络传输；2 阅读机器级程序(因为程序的二级制表示都是字节序列，跟数字的写法不一样)；3 将指针类型进行强制转换后，利用初始地址和字长进行寻址，即指向的是一个字节序列，而不是一个数据类型对象。这个时候就需要非常清楚数据到底是按照什么方法进行存储的

- 书写**字节序列**的自然方式是最低位字节在左边，最高位字节在右边。这和通常书写**数字**时最高有效位在左边，最低有效位在右边的方式相反(所以得搞清楚到底写的是数字还是字节序列，所谓字节序列就是存储空间存的值是多少)

- 文本数据比二进制数据有更强的平台独立性，因为对每一个数字或者字母都是按照一个byte来编码的，不存在说占用多个字节

- 二进制代码是不兼容的，即使是同样的代码，在不同的系统上的不同编译器，出来的结果都是不一样的

- 有符号整数都是用补码的形式来表示的

- 在C语言中，处理同样字长的有符号和无符号数之间转换的规则是：位级不变，只改变每一位的解释权

- 扩展一个数字的位表示：无符号数的零扩展(在无符号数的前面添加若干位的0)；有符号数的扩展(在有符号数的前面添加若干符号位，1或者0)，这样扩展的目的就是使得最后的结果无变化，按照相应的规则转换出来的仍然是原来的结果

- short->unsigned的时候，先是转换成int，再转换成unsigned这个是C语言规定的

- 逻辑移位：仅考虑移位而不考虑符号位

  算数移位：需要考虑符号位；

  当数为正数的时候，左移右移都是补0

  当数为负数的时候，左移右边补0，右移左边补1

- 截断数字的时候，直接丢弃高位。

  当操作的是无符号数x的时候，将x由w位变成了k位，就是直接x mod $2^k$；原理就是，比k高的位在对$2^k$取模的时候都为0，因此就跟原来的数相同(可以用到后面的加法乘法溢出的时候)

  当操作的数是有符号数x的时候，同样的是由w位变成k位，先对x取模，然后再用有符号来表示

### 浮点数在计算机内的表示

#### format

$$
value = (-1)^sM2^E\\ 
M = 1.frac\\
E = Exp - Bias\\
$$

- S is the sign of the number

- E = EXP-Bias, EXP is the exponent field(unsigned number)
$$
Bias = 2^{k-1} -1
$$
  k is the bits of the exponents

  因此在这种情况下： 0=<Exp<=255,  -127=<E<=128
- denormalized numbers are those whose exp is equal to 0 and now E is defined as 1-Bias not exp - Bias.

  $M = frac$  not  $1.frac$ 因此可以表示 +0.0 因为尾数$M=0$，实际上-0.0是符号位为1的时候后面全0，这个时候两个之间还是有些差距

  同时denormalized value 还可以表示非常接近0的数，因为后面的阶码很小，而且均匀地接近于0

  $E = 1-bias$ not $-bias$ 因为可以平滑的转换

- nornallized numbers' exp are not 0 使用1.frac可以多获得一位的精度，比如100.01可以用1.00后面调整阶码来表示

- when frac is 0 & exp = 111... the value is **Inf** (maximum with the current bits) 正无穷或者是负无穷

  当frac不是-0， exp=111……的时候，表示的不是一个值 NaN(not a number)

#### Example

**十进制数转小数**

- F=15213.0
  $$
  15213_{10}=11101101101101_2\\
  =1.1101101101101_2\times2^{13}
  $$
  因此
  $$
  M=1.1101101101101_2\\
  frac=11011011011010000000_2\\
  E=13
  $$
  因此可以得出相应的Exp和frac部分和s部分，因此可以得出最终的结果

#### Properties

- denormalized number是均匀分布的因为阶码部分都是一样的，不同的只是尾数部分，而尾数部分则都是加上同样大小的数
- 同样的阶码时，间隔都是相同的；阶码不同造成间隔越来越大
- 与此同时，如果把其中的位按照无符号数去解释，发现是升序排列的，就是说它能够和整数一样去进行比较

#### 舍入

由于表达小数肯定是有误差的，因此选择舍入的方法

- 向零舍入、向下舍入、向上舍入(只是得到一个确界)

- 向最近的偶数舍入(舍入到一个最接近的值)，在求一组数的时候，这种方法会产生效果。如果都是向某个方向舍入的话，那么在求统计平均值的时候，会造成整体结果偏向某个方向。而如果使用偶数舍入的话，他会有50%的机会向上，50%的机会向下，因此避免了统计误差。

  1.235000和1.245000，这两个数，如果同时舍入为最近的偶数，那么都是1.2400！！！

  换到二进制数中时，就是如果是中间的数，倾向于舍到最低位为0，非中间数那自然简单。四舍五入，在二进制中就是相邻的那位0舍1入(只有在正中间的时候才是这样取)

#### 浮点数运算

**乘法**

只需遵循乘法规则，在M大于1的时候适当使用阶码去移位即可；也不具有结合性

**加法**

加法很容易出现问题，尤其是当两个数差很远的时候，比如3.14+2^10，这个时候浮点数的表示只能够是表达那个大数，而对于这个小数他没有足够的精度去表示，因此便舍掉了

正因此，加法在有些情况下不具有结合性

浮点加法也是有逆元的，就是说可以找到一个数是他们之和是0

任何对NaN和无穷大的数操作得到的结果都是NaN和无穷大

#### 浮点数的转换

浮点数的转换和整数的转换不同，他会改变位级的表示

具体的转换原理如下

根据浮点数的表示来看，其frac精度实际上代表的就是他能表示的精度；对于float型的来说，frac有23位，由于阶码的阶数肯定能将小数点移完，因此，最高的精度就是23位，后面的可能都是舍入了。

因此将int 转换为flaot的时候，显然会有精度丢失；将float转为int的时候，如果能转，不会有丢失，如果不能转那就另当别论

浮点数是有正负确界的，因此即使溢出，也会溢出到正负无穷大


#### 有符号数的乘法公式

负数用补码！！！！！！！！前面补到2N位，无符号的一样要补到2N位，不过是用0来补

![](C:\Users\牧羊人\AppData\Roaming\Typora\typora-user-images\image-20200612092614781.png)

## 机器级程序编

工具：gcc -Og -S 不使用优化等级生成的汇编代码，产生汇编代码(后缀名是.s)

### 机器级代码

对于机器级编程来说有两种非常重要的抽象

1：指令体系架构(Instruction Set Architecture ISA)

定义了机器级程序的格式和行为，处理器状态，指令格式，以及每条指令对状态的影响(有点像有限状态机)

2：使用的内存是虚拟地址

内存模型看起来是一个非常大的数组，实际上则是将多个硬件存储器和操作系统软件组合起来的结构

### 汇编代码中的一些特性

- 指令长度从1个字节到15个字节不等；对指令进行编码的时候，从某个给定位置开始，可以将字节唯一地译码成机器指令

- 在链接过后，程序的总长度将会变大，这是由于还包含了启动和终止程序的代码以及用来和操作系统交互的代码

- 每一个函数调用都是根据主函数的地址来决定的，所以连接的作用。首先是将代码的地址移到了一段不同的地址范围中，其次是在调用的时候添上了真正的地址，最后是对程序的补齐方便下一个程序的放置

- 以.开头的命令都是指导汇编器和链接器工作的伪指令

- x86-64的中央处理单元(CPU)包含一组16个存储64位值的通用寄存器

  如果对寄存器只操作低字节，那么高字节的内容遵循如下规则

  1. 生成1或者2字节的数字指令会保持剩下的字节不变

  2. 生成4字节的指令会把高四位字节置0

     都是根据指令的操作不同而有不同的结果

- 寻址方式 

  $Imm(立即寻址方式)

  Imm(rb,ri,s) 比例变址寻址。s为1 4 8，rb为基址寄存器，ri为变址寄存器 ，任意一个都可以省去，但是需要流出空

  寻找的地址是这个 $MeM[Reg[rb]+s*Reg[ri]+Imm]$

  R[ra]表示 ra寄存器里的值

  M[rb] 表示用寄存器里的值找到存储器的值

  使用方法：(ra, rb)表示在存储器中找值；普通的ra rb就表示寄存器中的值；-12(ra)就是立即数也算上去

- movq 只能以表示32位补码数字的立即数作为源操作数，然后扩展为64位放到目的中

  movzbw：将byte的数移到word中并使用零扩展

  movsbw：将byte的数移到word中并使用符号扩展

  cltq：把%eax扩展到%rax，按照符号扩展

- 压栈是先减少 %rsp堆栈指针，然后再将数字移到栈中去

  可以用标准的寻址方式访问到栈中的任意一个元素

  注意出栈的时候那个值并未被删除，而只是读出，并改变了%rsp

  %rip 指令指针 无法正常访问到

- 指令分为：加载指令(leaq——load effective address，从内存读取指令到寄存器 目的操作数是寄存器，将前面计算的地址放到后面的寄存器中)、一元操作、二元操作和移位

  %rax %eax %ex %ah %al 64 32 16 8 8

- 除了整数寄存器，CPU维护着一组单个位的条件码寄存器，表明最近的算数或者逻辑操作的属性

  CF：进位标志，最近的操作使得最高位产生了进位，可以用来检测无符号溢出

  ZF：零标志，最近的操作得出的结果为0

  SF：最近得到的操作数结果为负号
  
  OF：最近的操作导致一个补码溢出，正溢出或者负溢出
  
  leaq指令是不改变任何条件码的，他只计算地址；不同的操作会对不同的标志位起到不同的作用；
  
  CMP指令只是比较两数的大小并设置条件码 CMP S1，S2 ->S2-S1
  
  test S1, S2 S1&S2，只设置条件码
  
- set指令来使用条件码
  
  当满足某条件的时候，把某个Destination设置为1或者0
  
  **传递参数的时候一般是第一个参数在rdi里面，第二个参数在rsi里面，第三个在rdx**
  
  sete 如果后面两个数相同就把那位设为1
  
- 跳转指令：
  
  跳指令一般使用伪代码.L之类的来表示，但是在最后还是会填上真正的地址，并且这个地址会被编码成跳转指令的一部分；也有用 *%rax 作为跳转目的 jmp *(%rax)
  
  **跳转指令的编码**
  
  跳转指令的编码一般是PC相对跳转，就是下一条指令的代码地址加上偏移量得到新的执行地址，而这个偏移量被编码到二进制代码中(注意这里都是补码表示，因为需要表示向后跳转还是向前跳转)；这样做的好处就是，在链接的时候不用改编码就可以，因为只要PC的地址确定就可以找到下一条语句的位置

### 过程

1. passing control
2. passing data
3. managing local data

- 栈帧：当寄存器无法存放的时候，会将多余的东西放到栈中，这个多余的部分称为该过程的栈帧

  ![image-20200720093117743](C:\Users\牧羊人\AppData\Roaming\Typora\typora-user-images\image-20200720093117743.png)

  1. 当过程P调用过程Q的时候，会将最后需要返回的地址压入栈中，这样当Q返回的时候就可以直接到P中的下一个地址执行，这个返回地址称为P栈帧的一部分，因为他存放的依然是P过程的一部分。
  2. Q的代码会扩展当前的栈帧边界，它可以保存寄存器的值，分配局部变量的空间，设置参数。大多数过程的栈帧都是定长的，在过程的开始就分配好了，但是有的时候仍然需要变长的帧
  3. 使用通用寄存器过程P最多可以传递6个整数值(指针和整数)，如果需要更多的参数，P可以在调用之前在自己的栈帧里存放好这些参数
  4. 栈帧并不是一定会创建的，有些需要的资源不多，自然也就不需要创建栈帧
  5. 在释放栈帧的时候，如果是定长的栈，比如开始分配16个字节就够了，那么就不需要使用%rbp来指定要回到的位置，因 为我可以直接释放16个字节的东西；如果是动态分配的，那么就需要%rbp来指示栈需要返回的位置；并且会在程序中显示的修改栈帧的位置，ret只是把stack——point指向的地方弹到rip里面，所以修改point的工作要自己做
  6. 栈在存储数据的时候是向上存储的，比如先直接分配16个bytes，然后要存放一个long类型的值，那么就直接在%rsp+8的位置存在这个值就可
  7. 并不是每一个过程都有自己的栈帧，有时候嵌套调用只用一个栈帧，只分配一次

- call Q 调用过程Q，这个指令会将P过程的下一条指令的地址压入栈中，PC赋值为Q的地址；在ret的时候，又会将栈顶的数据弹出来，并且重新赋值给PC

  **call的机器级代码中会包含有将要跳转的地址信息**

- 参数传递的时候一般使用的是寄存器，**传递参数的时候一般是第一个参数在rdi里面，第二个参数在rsi里面，第三个在rdx，第四个rcx，第五个r8，第六个r9——64位参数的情况**

  多于6个参数的时候，就从右往左进行入栈，栈顶的元素是第七个参数(**这部分称为栈帧的参数构造区**)，并且向8字节对齐

  ![image-20200720091444484](C:\Users\牧羊人\AppData\Roaming\Typora\typora-user-images\image-20200720091444484.png)

- 对于局部变量，特殊情况则必须将参数放到栈上

  1. 寄存器不够存放局部变量
  2. 对某个局部变量使用了取地址操作，这样的话必须得使用栈
  3. 某些局部变量是数组结构
- 被调用者不能修改调用者稍后要用到的寄存器参数，因此有一个专门的寄存器组(%rbx,%rbp,%r12~%r15 被划分为被调用者保存寄存器，当P调用Q的时候，Q必须保存这些寄存器的值，要保存寄存器中的值有两个办法 一是直接不改变他，而是将他压入栈中)，这部分压入栈中的寄存器的值称为保存的寄存器部分，如果Q有这个功能，那么P就可以安心的把值放到被调用者保存寄存器了

  caller save：P比较重视这个寄存器里面的值，那就先压到P的栈帧里面，在返回的时候再弹出来

   and callee save：Q要修改这个寄存器里面的值，又怕伤害到P，就自己帮他保存，在返回的时候弹出来

  ![image-20200720100347342](C:\Users\牧羊人\AppData\Roaming\Typora\typora-user-images\image-20200720100347342.png)

  ![image-20200720100421543](C:\Users\牧羊人\AppData\Roaming\Typora\typora-user-images\image-20200720100421543.png)

  如果rbp不是一定要用的，那么就可以当作是callee-saved register

  被调用者一般都有pushq %rbx的操作

- 其他的寄存器 除了%rsp之外都被称为调用者保存寄存器，就是在调用其他过程的时候，P自己需要将这些值压栈，这样被调用者据可以随意修改了

- 递归函数比普通函数要更多的入栈出栈操作，因此会比较复杂

  test是相与的意思；je是等于0就跳转的意思

### 数组

 数组名在大多数的时候都被视为指针常量，但是在sizeof(a)和&a的时候不同；

sizeof(a)返回数组a的长度(多少个字节)

&a 返回的是数组的地址，与首元素的地址相同，但是两者不是一个东西；可以看到，首元素的地址加上一个常数和数组地址加上一个常数结果是不同的

e.g. a = {1, 2, 3} 

&a 的 值与a相同，因为只要不是上述两种特殊情况，a都被隐式的转换为第一个元素的地址；而&a则返回的就是数组的地址，编译器规定的。

在机器级代码中进行访问的时候，都是以byte为单位的，因此访问的可能会不同一点。比如对于一个二维数组A\[N][N]，要想访问A[i]\[j]，就必须使用A的初始地址，然后 Add = A+i\*(C\*K)+j*K

对应的汇编代码就是先将index乘以同样的倍数，再做加法运算

```assembly
int fix_ele(fix_matrix a, size_t i, size_t j)
{
	return a[i][j];
}

salq $6, %rsi # 64*i
addq %rsi, %rdi #a + 64*i
movl (%rsi, %rdx, 4), %eax # M[a+64*i+4*j]
ret
```

如果在编译的时候不知道长度，那么需要使用乘法指令

### 结构体

结构体在编译的时候，编译器是知道每一个选项的位置的；因此在生成汇编代码的时候，会出现某个具体的值。

### 联合

Unions的作用就是一旦初始化 你就只能用这一个东西，在内存的角度看，就是他会开辟联合里面最大的空间，并不是所有的空间；意义就在，我可以把一块空间当成很多可能去看

**数据对齐的原则：**

一个大小为K的对象，其地址要是K的倍数；x86不必须要对齐，但是有些机器上必须对齐

![image-20200720145252308](C:\Users\牧羊人\AppData\Roaming\Typora\typora-user-images\image-20200720145252308.png)

让结构的初始地址是结构体中最难对齐的那个(也就是需要位数最多的那个)位数的整数倍；因此把大的放在结构的前面

### 缓冲区溢出(buffer overflow)

 段错误一般都是程序跳转到了一块内存，这里完全无法执行，因此会让程序崩溃。但有些时候，改变一点而那个地方正好有代码且不会crash the program那么错误不会太严重

不同程度的overwritten 会造成不同的结果，有时会破坏未被使用的栈空间，有时会直接破坏返回地址，还有时会破坏caller中保存的状态

比如exploit code，用一些字节覆盖掉返回地址，而这些字节就是跳转到攻击代码的指针，能实现这种攻击的前提是，执行同样一段程序，先后两次的内存分配都是差不多 的。

所以克服的一种办法是：

1. 栈随机初始化，每次分配的时候都是随机的

2. 栈破坏检测，在返回地址和局部区中间插入一个哨兵，这样一旦发现哨兵被修改了，就能够发现被攻击。

   具体做法是：通过段寻址，在内存中找出一个值放到，局部区和状态区之间，然后在返回的时候通过比较该处的值与原来内存中的值，如果不相同，则产生错误代码

### 变长栈帧

一般编译器是可以直接确定栈的大小，但是有些时候还是需要变长栈帧，比如变长数组，这里使用的方法就是利用%rbp和%rsp一起对当前栈帧进行标识。在结束的时候使用leave这个指令就可以，等价于实现 movq %rbp, %rsp pop %rbp两条指令

### 浮点代码

- AVX浮点体系结构允许数据存储在16个YMM寄存器中，他们的名字是%ymm0\~%ymm15，每一个YMM寄存器都是256位，当对标量数据操作的时候，这些寄存器只保存浮点数，而且使用低32位，这些低位的名字为%xmm0\~%xmm15
- 对浮点数的操作有一系列的指令，如vmovss, vmovss等

## 程序优化

编写高效程序需要：

1. 适当的算法和数据结构
2. 编写编译器能够有效优化以转换成高效可执行代码的源代码

## 存储器层次结构

- 存储器系统是一个具有不同容量、成本和访问时间的存储设备的层次结构，与操作系统一起构成一个逻辑上大的数组。

- 能够这样做的原理：程序更倾向于频繁地访问某一个层次上的存储设备，因此下一层的存储器可以慢一点，节省成本

- 访问CPU寄存器中的数据基本不消耗时间，访问高速缓存需要4~75个周期，访问主存的数据需要上百个周期，访问磁盘数据需要几千万个周期

- SRAM需要更多晶体管，一般作为高速缓存存储器，并且只要有电就不用刷新，断电就会丢失信息(Volatile)

  Flash memory：实际上也是一种EEPROM(Electrically eraseable ROM)，能够部分擦除(这是跟Electrically ereable ROM不同的地方)

### 信息在系统中的流动

![image-20200723095323295](深入理解计算机系统.assets/image-20200723095323295.png)

首先，将要执行的程序是放在主存上的，%rip指向下一条将要访问的语句。将代码传到芯片内部的ALU进行处理，比如这里的movq指令。将编码产生的地址(A的地址)拉到总线上，存储器感知到是在读自己，因此将A上的数据放回到数据总线上，内部芯片再将这里的数据读入，交给ALU，进行下面的操作，这里是直接放到%rax里面。

### 磁盘存储

磁盘由盘片构成(Platter)，每个盘片有两个表面(surface)，表面有磁性记录材料。

中央有一个主轴，使得磁盘以某一个固定的速率旋转，每一个表面有同心圆叫做磁道。

每个磁道被分为一组扇区，每一个扇区包含数量相等的数据为(512字节)，扇区之间有间隙(gap)，间隙没什么作用。

磁盘容量：一个磁盘记录的最大位数称为其容量，由以下参数决定

1. 记录密度：磁道一英寸的段中可以放入多少位
2. 磁道密度：从盘片中心出发半径上一英寸的段内可以有的磁道数
3. 面密度：记录密度与磁道密度的乘积

目前的磁盘使用的是多区记录的技术，不同的柱面构成集合，称为区(比如内圈的两个柱面构成一个区，外面3，4又构成另外一个区)，每个柱面中的每条磁道数有相同的扇区，这个扇区数量由该区最里面的磁道所包含的扇区数决定。

真正计算的时候一般会给出每个磁道平均的扇区数，这个数在不同的磁道上不同，但是会有一个平均值

![image-20200723100253245](深入理解计算机系统.assets/image-20200723100253245.png)

#### 磁盘操作

磁盘用读写头来读写存储在磁性表面的位，首先需要寻道，找到该读的位在哪一个磁道上，然后再读，每一个盘上都有一个双面的这种读写头。

读写需要的时间有三个主要的部分

1. 寻道时间：从一个磁道转移到目标磁道所需要的时间
2. 旋转时间：从当前位置转到读的地方需要的时间
3. 传送时间：读下来之后传给主存需要的时间

有如下性质

1. 读取512字节实际不需要花时间，时间都用来找到这个扇区的第一个字节。
2. 寻道时间和旋转延迟大致相同，寻道时间由于是机械运动，因此耗时比较多

为了简化操作，使用逻辑磁盘块(也就是让操作系统认为磁盘是一个大的数组，有逻辑编号的数组，但是磁盘控制器存储了逻辑和真实的映射关系)

1. 磁盘里面有一个专有硬件(磁盘控制器)，维护逻辑编号和实际物理磁盘位置的映射关系。
2. 当要读数据的时候，操作系统只是传递逻辑号，然后让硬件去翻译成具体的物理地址，最后去读出来

- 固态硬盘SSD则不同，不旋转。

### IO设备

有三种不同类型的设备连接到总线

1. USB：通用串行总线(Universal Serial Bus)，用来连接各种外围设备
2. 图形卡：负责代表CPU在显示器上画像素
3. 主机总线适配器：将一个或者多个磁盘连接到IO总线，使用主机总线接口定义的通信协议(SCSI和SATA)

![image-20200723103714576](深入理解计算机系统.assets/image-20200723103714576.png)

1. IO Bus与CPU的胸痛总线不相关,这种类似于一种广播形式的,所有的外围设备都连接到一根总线上。虽然现在的不是总线结构，但是变化也不大

2. 具体操作外围设备的时候，实际上是地址空间中有转专门的一块地址是为了IO通信而保留的，这样的地址称为IO端口，当设备连接到总线的时候，他会映射到一个或者多个端口，就是一个外设可以有多个地址。
3. 例如，CPU发出磁盘读的命令，在磁盘进行读的过程中，如果CPU一直等待就太浪费了，因此发出指令后，就直接然DMA将数据送往主存，而不需要CPU监视。最后通过中断的方式通知CPU，DMA(直接内存访问)

### SSD(Solid State Disk)

- SSD分为闪存翻译曾和闪存，闪存翻译层类似磁盘控制器

- SSD的闪存由B个块组成，每个块由P页组成，每一页大概512\~4KB字节，一个块中包含32~128页。

  数据以页为单位读写，只有一页所属的块被整个擦除之后才能写这一页(通常是该块所有位被置1)

### 局部性

#### 时间局部性

被引用的内存位置很可能在不远的将来多次被引用

#### 空间局部性

一个内存位置被引用一次，可能在不远的将来引用附近的内存位置

局部性还有指令的局部性和数据的局部性

### 存储层次结构

1. cache，高速缓存，作为更大、更慢的设备中的数据对象的缓冲区

   每一层都缓存来自下一级的数据，直到CPU的寄存器组

2. 第k层更小、更快、更昂贵的设备，缓存着第k+1层块的子集

   比如第K+1层中分为0\~15个块，第K层可能就只有其中的前4块，注意层次越低块就越少

   层与层之间传递数据是以块为单位进行访问的。且不同的层次，块的大小还不一致

3. 缓冲命中：当程序需要第K+1层的某个数据对象的时候，他会现在第K层的块中寻找，如果在，那么就是缓冲区命中。反之称为缓冲不命中(cache miss)。不命中后就会从K+1层取出包含d的那个块，然后放到第k层，如果第k层满了，就会覆盖现存的一个块。

   覆盖的这个过程叫做替换或驱逐，被驱逐的块称为牺牲快

   **不命中的种类**

   1. 冷缓存，第k层直接是空的，没数据，称为强制性不命中或者冷不命中。

      因此在做覆盖的时候，需要选择好具体的放置位置，一种防止策略是第k+1层的块i必须防止到第k层的块(i mod 4)中。

      冲突不命中：是很多K+1层的块映射到第k层的同一个位置。比如 CPU请求0 8 0 8，这样就对导致每一次都不命中

      容量不命中：工作集的大小已经超过了缓存的大小，自然容易引起不命中

#### 高速缓存存储器比较重要的那个缓存

 SRAM高速缓存，L1, L2级的缓存，引入这些缓存的目的就是CPU跟主存之间的差距越来越大

**组织结构**

 考虑一个计算机系统，存储器有m位，因此可以形成M=$2^m$个不同的地址。

考虑一个缓存S=$2^s$，由S个高速缓存组构成，每个组有E个缓存行，每一个缓存行由**一个B=$2^b$字节的数据块组成**，其中包含一个有效位来指明这个行是否包含有意义的信息，还有t=m-(b+s)个标记位，他唯一标识存储在这个高速缓存行中的块

   ![image-20200723150313007](深入理解计算机系统.assets/image-20200723150313007.png)

 地址共m位，在这里可以理解为3段

   1. 标记：t位
   2. 组索引：s位
   3. 块偏移：b位 
      4. 并且是 t s b顺序排列的

 s可以编码所有的组，因此可以用s位来找到对应的组索引，标记t可以用来告诉是哪一个缓存行，每一个缓存行里的数据用b位来编码(这里注意单位是byte)，因此用b可以找到哪一个块

CPU给地址，高速缓存拆解成三个字段，先找到set，再找行，再找块，这里找块还要考虑到数据类型，比如int，就是向后找4个bits

1. 组选择：抽取对应位置的s位，这些位被解释称一个无符号整数。
2. 行匹配：

#### 直接映射高速缓存

E= 1，每一个set里面只有以一个缓存行，行里面有一个块，这个块B个byte。因此tag和S一起唯一标识了块号。

这里会出现多个块映射到一个换存组当中，因为块多而缓存组少。但是映射到同一个缓存组的块被标记位唯一标识，明显看到tag位有时候直观看起来有些多余，但事实上却标识了映射到同一个缓存中的不同块 。

- 当valid位有效且两者的tag相匹配的时候，发生命中；反之，如果tag不匹配，那么就会发生miss，然后从下一层里的位置取数据覆盖掉原来的内容。这个时候，tag位会改变成有效的那个。

- 当只有一行的时候很容易就发生高速缓存不命中，这就是因为很多都映射到了同一个set，解决办法就是一个Set里面多个行，用tag来标记

  每次查询的时候比较每一个行的 valid 和 tag，所以这个时候，如果所有的情况的tag都考虑，也就是说e = t，那么会造成硬件非常复杂和贵

- 当E>1的时候如果发生不命中，那么就要选择一行去驱逐，这个时候的策略就是去选择那些最近未使用过的(表达这个可能需要更多的一位)

- block的size需要先确定，再看需要多大的缓存，由设计者确定，block的大小取决于locality

- 而且组索引使用的中间位，为什么不直接用高位来做组索引，这是因为如果使用高位做组索引，那么连续的内存块会被映射到缓存区的同一块。

### 写缓存

#### 直接写

更新后直接写

#### 写回

更新后尽可能推迟写回的时间，这就需要多加一位来指明这个行是否被修改过。产生这种想法的原因就是，如果一改就写，那么会造成总线上非常大的流量(与局部性有关，因为一般写的时候周围的数据也要写)

#### 写不命中

解决办法是**写分配**

就是在发生写不命中的时候，把下一层的数据加载到这层，然后再更新；另一种是非写分配，直接写底层

`现在操作系统基本就是写回和写分配`

### 真实高速缓存层次结构

![image-20200723173131841](深入理解计算机系统.assets/image-20200723173131841.png)

**i-cache**：只读，之缓存指令

**d-cache**：只缓存数据

其他的基本都是uniform cache，统一高速缓存

#### 高速缓存性能参数

不命中率：执行期间不命中的比率

命中率：1-不命中率

命中时间：从缓存传送一个字到CPU所需的时间，包括组选择、行确认、字选择的时间

不命中处罚：miss的时候会花费其他时间，用来从下一层缓存读取数据到这一层

高速缓存大小、块大小、相联度、写策略都会影响

> 行、组、块的区别
>
> 块：固定大小的信息包
>
> 行：高速缓存的一个容器，包含存储块和其他信息(有效位和标记位)，有效位实际上就是标识当前这个数据不是初始的数据
>
> 组：多行的集合

### 高速缓存友好程序

1. 对局部变量反复引用是好的，因为直接会被保存到寄存器文件中
2. 步长为1的模式是好的，，因为不命中率低的多，因为都是以块存储的，自然如果步长大的话容易不命中

### 存储器山

程序从存储系统中读数据的速率称为读吞吐量，或者读带宽。如果一个程序再s秒的时间内读n个字节，那么读吞吐量就是n/s 通常是(MB/s)

z轴是吞吐量，x,y分别是stride和size，stride越大说明spacial locality不行。size很大，说明时间局部性不行

这样画出来的图是Memory Moutain

## 链接

定义：链接就是将各种代码和数据段收集并组合成为一个单一文件的过程，这个文件可以被加载到内存并执行。

链接可以执行于编译的时候，也可以执行于加载的时候，甚至是正在运行的时候

链接的意义，就是不用将源文件变的非常大，每次改完之后要重新编译再跑；链接就是将文件拆成很多部分，每一部分编译完后可以直接用；如果其中有文件修改了的话，其他的文件不用重新编译

编译器实际上就是编译器驱动程序：实际上就是一个写的特好的程序。(compiler driver)

编译系统包括：语言预处理器、编译器、汇编器、链接器

编译系统的过程如下

> main.c -> main.i # 经过语言预处理器(CPP)翻译成一个ASCII码的中间文件
>
> **命令**：`cpp main.c`
>
> main.i -> main.s # 经过编译器(CCL)将main.i翻译成ASCII汇编语言文件 main.s
>
> 命令：`ccl main.i`
>
> main.s -> main.o # 经过汇编器将main.s翻译成可重定位目标文件(relocatable object file)main.o
>
> `as -o main.o main.s`
>
> main.o -> main # 经过链接器将main.o和一些必要的目标文件组合起来，创建一个可执行目标文件(executable object file)
>
> `ld -o main main.o sum.o`
>
> ./main # 执行main函数
>
> `shell 调用操作系统中一个叫加载器(loader)的函数，他将可执行文件中的代码和数据复制到内存，然后将控制转移到这个程序的开头`

### 静态链接

**Linux的LD程序这样的静态链接器，可以将一组可重定位的目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行程序作为输出**

**可重定位目标文件由各种不同的代码和数据节组成，每一节都是一个连续的字节序列，指令一个节、初始化的变量在一个节、未初始化的变量在一个节、还有包含引导连接器和加载器的数据结构**

### 目标文件

1. 可重定位目标文件：待结合的二进制代码和数据
2. 可执行目标文件：可以直接加载到内存执行的二进制代码和数据
3. 共享目标文件(shared executable file)：可以在加载或者运行时被动态加载进内存并连接的二进制代码和数据

一个目标某块是一个字节序列，一个目标文件是以文件的形式存放在磁盘中的目标模块。目标文件是按照特定的目标文件格式来组织的，不同的目标文件格式不相同，但第一个是Unix系统使用的a.out格式，到现在仍然称a.out。Windows上使用可以指可执行格式(Portable Executable)，Linux和Unix使用可执行可链接格式(Excutable and linkable Format ELF)

#### 可重定位目标文件

ELF可重定位目标文件格式

![image-20200723201502271](深入理解计算机系统.assets/image-20200723201502271.png)

> ELF头：以16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。剩下的部分包含帮助链接器语法小分析和解释目标文件的信息，包括ELF头的大小、目标文件的类型(可重定向、可执行或者共享)，机器类型，节部头表的文件偏移
>
> .text：已编译程序的机器代码
>
> .rodata：只读数据，比如printf语句中的格式串和开关语句的跳转表
>
> .data：已初始化的全局和静态C变量，局部变量在运行时被保存在栈中，既不出现在.data节中，也不出现在.bss节中
>
> .bss：未初始化的全局变量和静态变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节实际不占据实际空间，仅仅是一个占位符
>
> .symtab：符号表，存放在程序中定义和引用的函数和全局变量的信息
>
> .rel.text：一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。就是原来连接之前的地址都是相对地址，链接的时候才真正的把真实地址填上去。
>
> .debug：调试符号表，其条目是程序中定义的局部变量和类型定义，只有以-g调用的时候才驱动这个



#### 符号和符号表

就是类似变量名和函数名，这个表说明了这些符号的属性

有三种不同的符号

> 1. 由模块定义并能被其他模块引用的全局符号——全局链接器符号，对应的是非静态的C函数和全局变量
> 2. 由其他模块定义并被模块m引用的全局符号——外部符号，对应于其他模块中定义的非静态C函数和全局变量，就是external定义的，在其他模块被定义(在当前某块要声明，或者默认就是)
> 3. 只被m定义和引用的局部符号，对应的是static的C函数和全局变量。想让其他人看到的不用static声明，想私有的就用static声明。这里就说明了为什么要用模块而不是直接用源文件来描述，这里的功能模仿了类可以保护变量的做法，只不过使用文件来充当这个类的保护功能
> 4. 注意局部变量放在栈里面，跟这个东西无关
>
> `定义为static属性的局部变量不在栈中管理，而是再.data或.bss中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符号`
>
> `static相当于是一种保护关键字，被声明的函数名和全局变量名属于当前模块，而不被其他模块访问`
>
> linker完全不清楚局部变量

#### local non-static val vs local static val

```C
int f()
{
	static int x = 0;
	return x;
}

int g()
{
	static int x = 1;
	return x;
}
```

这里编译器在.data段为x分配空间，创建local symbols in symbol table with unique name：x.1 and x.2

#### Linker's symbol rules

1. 不同模块定义的强定义是不允许的，直接报错

2. 如果有强定义的和几个弱定义的，那么选择强定义的。这里所谓强定义就是被显示赋了初值的。函数名的赋值就相当于是写函数体，写了函数体的就是强定义，因此有声明和定义的区别。

3. 如果几个都是没有赋初值的弱定义那么随便选一个，但是如果同名且都是弱，但是定义的形式不同

   ```C 
   int x;
   int y;
   p1(){}
   
   double x;
   p2(){}
   
   //如果链接选择了double x，那么引用x的时候实际上把y也引用了，因为double的字长是8，在p2中引用x的时候会覆盖y
   
   int x = 7;
   int y = 5;
   p1(){}
   
   double x;
   p2(){}
   // 这里在p2里面使用x的时候依然是当作double使用，也就是说他会去找8个byte，但是实际中x并不是8个byte，因为链接器为他选的是int x= 7，因此在p2中使用x的时候会修改掉y的值
   ```

   多用external这个关键词

#### Relocation重定位

![image-20200724082425760](深入理解计算机系统.assets/image-20200724082425760.png)将系统的启动代码段和数据段与main.o和sum.o的对应段结合起来，放到一个可执行的二进制文件中。

1. 编译器是不知道具体的地址的，因为要和别人一起共同构成的文件才能分配，否则会冲突。因此在编译完的汇编代码中，就会有对应的relocation entry，linker看到这个之后就会知道，这个地方是要重新分配真实地址的。

   ```assembly
   000000000000000000<main>
   0: 48 83 ec 08         sub $0x8, %rsp
   4: be 02 00 00 00      mov $0x2, %esi
   9：bf 00 00 00 00      mov $ 0x0, %edi
   a: R_X86_64_32 array
   ```

   这里实际上地址都是offset，最终还是要linker来分配真的地址，比如另外一个文件sum.o，他编译出来code的地址这里填的也是0，这样的话就会产生冲突。

   下面那句话的作用相当于告诉linker上面那个送进%edi的值，要加上array的初始地址

2. ![image-20200724094435345](深入理解计算机系统.assets/image-20200724094435345.png)

   将可执行文件的对应位置直接加载到内存当中去，这里在每一个Linux内核中都一致。从0x400000开始，分别是

   > code segment, data segment, run-time heap, userstatck 和kernel virtual memory
   >
   > kernal virtual memory 在user模式下是看不到的
   >
   > heap 其实有两个，大的结构存在上面的heap里(malloc分配的时候)，小的结构存在下面的heap里


3. 重定位分为两步

   >1. 符号定义，就是将每个.o文件里面的对应节合并在一起，并且将内存地址分配给这些节和对应的全局变量。这个步骤之后，每一条指令和全局变量都有了唯一的运行时内存地址了
   >2. 符号引用，修改代码节和数据节中对每个符号的引用，这依赖于重定位条目(.o文件中的一个`数据结构`)
   >
   >R_X86_64_PC32：重定位一个使用32位PC相对地址的引用，就是指令中的数加上当前PC的值，得到有效地址
   >
   >R_X86_64_32：重定位一个使用32位绝对地址的引用
   >
   >对每一个全局符号，汇编器都会产生一个重定位条目，显示在引用的后面一行，这些重定位条目告诉链接器对全局符号的引用应该如何来进行重定位。
   >
   >具体的重定位过程如下

4. 重定位PC相对引用：linker看到一个全局的名字，就会对应生成一个数据结构来描述，叫做是重定位条目，该条目由4个字段组成`r.offset,r.symbol, r.type, r.addend`，描述了linker到这里如何给全局名字分配真的地址

   具体例子参照`P516`，基本想法就是根据上面的描述计算出需要改动的命令。在这里，像是callq等等都是前面命令编码一个字节，后面是地址，编译结束的时候这些都是000000，在链接的时候重新将计算的地址填到对应的指令中。

### 静态链接库

1. 一般来讲，linker就是将一组可重定位目标文件链接起来，形成输出的可执行文件。但是把所有相关的某块打包成一个单独的文件，又可以称为静态库。

2. 静态库的引入是为了省时，将标准库仅仅放在链接的时候引入，而不是编译的时候，因为编译的话还需要在自己电脑上编译，很麻烦，而如果放在一个一个文件中，那么链接的时候需要指定所有的文件，也很麻烦。如果单纯的只是放到一个大的文件中，这样的缺点也很明显，每次运行的时候都要把整个文件加载到内存当中，且一旦要修改某一个函数，需要重新编译整个库，对内存的消耗也比较大。

> 1. 因此用静态库解决这个问题，所以静态库弄出来的跟普通的文件不一样，取了一个新的名字archive。
>
> 2. 这个archive实际上是.o模块的集合，每一个.o 文件都是一个库里面的函数，并且存储有对应的每个.o file的地址索引值。
> 3. 如果你在函数中只使用了printf，那么相当于只包含了printf.o这个文件在源文件中

3. 所以是先编译、汇编成.o文件，再用archive归档为archive格式的文件

   ```bash
   gcc -c addvec.c multvec.c
   ar rcs libvector.a addvec.o multvec.o
   ```

4. 头文件中一般包含的是函数的声明和一些全局变量的声明，include进来的的话，就相当于是将头文件的内容就直接放到了源文件。

5. 使用linker创建可执行文件的过程

   ```bash
   gcc -c main.c
   gcc -static -o main main.o ./libvector.a
   # 或者等价的使用
   gcc -static -o main main.o -L. -lvector
   # -L表示在当前目录下查找libvector.a -lvector是参数libvector.a的缩写
   ```

6. 静态链接库的具体做法

   >链接器维护一个可重定位目标文件的集合E，未解析(引用了但尚未定义)的符号集合U，在前面输入文件中已定义的符号集合D，初始的时候E U D都是空
   >
   >1. 对于命令行的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件，如果是一个目标文件，那么链接器把f添加到E，修改U和D来反应f 中的符号定义和引用，并进行下一个输入文件
   >2. 如果是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。这个检查会对存档文件中所有的.o文件进行，如果有匹配(之前引用未定义的在这里有定义)，那么就将m加到E中，并且修改U和D直到所有成员的目标文件都一次进行完这个过程，U和D不再发生变化。这个时候不包含在E中的成员目标文件都直接丢弃
   >3. 如果U是非空的，那么说明仍然有未定义的名字，直接报错
   >
   >**因此顺序特别重要，一般把.a文件放到最后，对于多个.a文件，顺序也有讲究，就是定义了名字的放后面，引用名字的放前面**

7. 符号解析其实完成的任务就是符号的引用和符号的定义对应，这个时候Linker就确切的知道每一个节的大小，也就能分配地址了。

### 动态链接库

静态链接库的问题

1. 更新非常麻烦，每一次的更新需要重新将所有的.o文件再组合
2. 如果每个进程都调用了I/O函数，printf之类的，那么每个函数代码都会被复制到每个运行的进程当中，这是一个极大的浪费

引入共享库的概念 .so结尾或者微软的操作系统DLL(动态链接库)

共享库以两种不同的方式共享

> 1. 对于一个库函数，只有一个.so文件，所有引用该库的可执行目标文件共享这个.so文件的代码和数据。而不是直接在链接的时候复制和嵌入到可执行文件中
> 2. 在内存中，一个共享库的.text节的副本可以被不同正在运行的进程共享

步骤

1. 将库函数编译成为动态链接库

   `gcc -shared -fpic -o libvector.so addvec.c multvec.c`

2. 与main.c合并成一个可执行文件，目前指明了main.c可以和动态库链接

   `gcc -o main main.c ./libvector.so`

3. Dynamic linker去处理最后的链接操作

   >1. 重定位libc.so的文本和数据到某个内存段
   >2. 重定位libvector.so的文本和数据到另一个段
   >3. 重定位main中所有对由libc.so和libvector.so定义的符号引用

 或者可以在运行的时候使用lib.c里面的函数在运行的时候去调用那个动态库

## 异常控制流

控制流，就是那一系列的指令，一条一条顺序执行

当**程序状态**发生变化的时候，有两种情况会改变控制流

1. Jump and branch
2. call and return

当**系统状态**发生变化的时候，也需要有东西来应对这个变化，这就是异常控制流(Exception Control Flow ECF)

> `system state`
>
> + Data arrives from a disk or a network adapter
> + Instruction divides by zero
> + User hits Ctrl-C at the keyboard
> + System timer expires

### 异常控制流发生在各个层次

### 异常

+ 异常是异常控制流的一种形式，他`一部分`由`硬件实现`，一部分由操作系统实现

+ 事件(Event)：状态的变化，事件的发生可能与当前的执行有关比如发生虚拟内存缺页，也可能与当前的执行没关，比如系统定时器产生信号或者I/O请求，`每一个事件都有一个unique index k`，最后跳转会跳转到表里面的第k项

+ 当处理器检测到有事件发生的时候，会通过一张异常表的跳转表，进行一个**间接过程调用**，到一个专门设计的子程序(`异常处理程序`)，完成跳转处理后，会发生下面三种情况之一

  1. 返回给当前指令

  2. 返回给下一条指令
  3. 处理程序中断当前运行的程序

+ 系统给每种类型的异常都分配了一个`唯一的非负整数的异常号`，其中`有一些编号是处理器的设计者分配`的，像被零除、缺页、内存访问伪例，断点以及算数运算溢出。还有操作系统设计者分配的，包括系统调用和来自外部I/O设备的信号

+ 系统启动的时候操作系统分配和初始化一张异常表的跳转表，表目k包含异常k的处理程序地址。跟8086的中断表类似，异常表的起始地址放在一个叫做异常表基址寄存器的特殊CPU寄存器里面

  异常类似过程调用，但是还是有很大差别。异常处理程序运行在内核模式下面，所有的项目都被压入到内核栈中，而不是用户栈，且对所有的系统资源都有完全访问权限

  **只要是满足下面这个东西的都叫异常处理，而异常处理也必须满足这个**
  
  ![image-20200725190337482](深入理解计算机系统.assets/image-20200725190337482.png)

1. 异常的类别

   > 中断：来自I/O设备，异步，总是返回到下一条只指令
   >
   > 陷阱：有意的异常，同步，总是返回到下一条指令
   >
   > 故障：潜在可恢复的错误，同步，可能返回到当前指令
   >
   > 中止：不可恢复的错误，同步，不会返回

   异常中，只有中断是异步的，就是硬件产生的，来了就触发。而同步则是由指令产生的。

   + 陷阱，主动做上面图的那个过程

     是执行指令的结果，返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。与硬件更接近

   + 故障

     故障由错误情况引起，它可能能够被故障处理程序修正，如果不能修正，就会返回到内核中的abort例程，会中止引起故障的程序。

2. Linux/X86-64系统的异常

   X86-64定义了0\~31号的异常，32\~255的异常是由操作系统定义的中断和陷阱。

   > 除法错误：如果试图除以0，那么Unix选择直接中止程序，shell通常将其定义为"浮点异常"
   >
   > 一般保护故障：例如引用了一个未定义的虚拟内存区域，一般不会主动恢复，Linux Shell将其称之为"段故障"

3. 系统调用

   很多跟硬件相关的操作，实际上都是C的库封装了系统调用，类似读文件、写文件这种，在汇编中其实用到的还是系统调用，syscall

   ```assembly
   mov $0x2, %eax
   syscall
   cmp $0xffff001
   ```

   syscall会使用%rax里面的数字，并且对应使用这个索引的systemcall，在这里就是open file

   > Linux提供几百种系统调用，当应用程序想要请求内核服务的时候，例如读文件、写文件或者是创建一个新进程。`每一个系统调用都有一个唯一的整数号`，对应于内核跳转表中的值

###  进程

Definition：运行起来的程序

进程上下文：进程运行时的，代码、数据以及栈、寄存器的内容，程序计数器，环境变量和文件描述符集合

进程提供两个最关键的抽象：

1. 一个独立的逻辑控制流，提供一个假象，好像程序独立占用了处理器
2. 一个私有的地址空间，提供一个家乡，好像程序独立的使用了内存系统

#### 逻辑控制流

PC，程序计数器在运行的过程中形成的序列称作是逻辑控制流。

在运行多个进程的时候，处理器的物理控制流被分成多个逻辑控制流。在时间轴上看，三个逻辑流是交替执行的。一个进程执行一段时间后，会被其他进程所抢占(preempted 暂时挂起)

![image-20200725193238292](深入理解计算机系统.assets/image-20200725193238292.png)

#### 并发流

两个进程在运行的时候，有一个没结束切到其他地方，后又切回来，那么这两个都算是并发(Concurrent)。就是在时间轴上只要能看到重叠，就行。

> A和B是Concurrent
>
> B和C是Sequence
>
> A和C是Concurrent

#### 进程地址空间

![image-20200725194951024](深入理解计算机系统.assets/image-20200725194951024.png)

#### 用户模式和内核模式

是通过CPU中的控制寄存位的模式位来表达的。用户模式中，不允许执行特权指令，如停止处理起、改变模式位、或者发起I/O操作，更不允许引用内核区的代码和数据。但是可以通过内核提供的接口来间接访问。

切换到内核模式的唯一方式是异常，处理异常的时候会变成内核模式，重新运行程序的时候又改回到用户模式

#### 上下文切换

操作系统内核使用一种称为`上下文切换形式的异常控制流`来实现多任务。

内核为每一个进程维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需要的状态，由一些对象的值组成，包括寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表以及已打开文件的文件表

在进程执行的某个时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这种决策过程叫做调度，是由内核中称为调度器的代码处理的。内核使用上下文切换的机制来控制转移到新的进程，步骤如下

> 1. 保存当前进程的上下文
> 2. 恢复某个先前被抢占的进程被保存的上下文
> 3. 将控制传递给这个新回复的进程

![image-20200725201927434](深入理解计算机系统.assets/image-20200725201927434.png)

一般是Process A运行而后发生一个异常，切换到内核模式，内核来决定是否切入到另一个进程。如果决定切换进程，那么就加载这个进程的上下文

#### 系统调用错误处理

当Unix系统级函数遇到错误的时候，通常会返回-1，但也有特殊情况返回void。并且设置全局整数变量errno来表示出了什么错误。

只要调用了systemcall函数，一定要检查返回值。

目前会使用包装处理函数来代替原来的函数，因为会更简单

```C 
Normal
if((pid = fork()) < 0)
{
	fprintf(stderr, "fork error:%s\n", strerror(errno));
	exit(0);
}
// strerror函数返回一个文本串，描述 某个errno值相关联的错误
可以通过定义
void unix_error(cha *msg)
{
	fprintf(stderr, "fork error:%s\n", strerror(errno));
	exit(0);
}
if((pid = fork()) < 0)
{
	unix_error("fork error");
}

//使用错误处理包装函数，可以更进一步地简化代码，将系统函数用一个开头大写的函数去封装
pit_t Fork(void)
{
    pid_t pid;
    if((pid = fork()) < 0)
    {
        unix_error("Fork error");
	}
    return pid;
}
```

#### 进程控制

每一个进程都有唯一一个正数(非零)进程ID(PID)

`getpid`返回调用进程的PID

`getppid`返回它的父进程的PID(创建调用进程的进程)

Linux中返回的类型为pid_t的整数值，在types.h中被定义为int

#### 进程的创建和终止

进程有三种状态：`运行`、`停止`、`终止`

运行的进程要么在CPU上执行，要么在等待被执行且最终会被内核调度

停止：进程的执行被挂起，且不会被调度，当收到SIGSTOP、SIGTSTP、SIGTTIN或者SIGTTOU信号的时候，进程会停止，并且保持停止直到它受到一个SIGCONT信号，这个时刻进程会再次开始运行

- 函数exit()以status推出状态来终止进程，另一种推出的方法是从主程序中返回一个整数值

- 父进程通过调用fork函数来创建一个新的运行的子进程。

  > 新创建的子进程几乎但不完全与父进程相同
  >
  > 子进程得到与父进程用户虚拟地址空间相同的但是独立一份的副本，包括代码段和数据段、堆、共享库以及用户栈，子进程还过的与父进程任何打开文件描述符相同的副本，这就是说，子进程可以读写父进程中打开的任何文件。`直接拷贝一整份`
  >
  > 最大的不同就是PID不同

- fork函数会有两次返回，一次是在父进程中，一次是在子进程中。在父进程中，**fork返回的是子进程PID，在子进程中fork返回的是0**，返回值提供一个方式来确定程序是在父进程还是在子进程中执行
- 父进程和子进程是并发的独立运行，内核以任何方式交替执行他们的逻辑控制流中的指令
- 地址空间是独立的。因此开始可能会有相同的局部变量，但是后面都是不想关的
- 共享文件。子进程继承父进程所有打开的文件，这就是说，如果都是输出 stdout，那么实际上父子进程打开的是同一个输出文件。

#### 回收子进程

- 当某个进程由于某种原因终止时，内核并不是立即把他从系统中清楚，而是使其处在一种已终止的状态，直到被父进程回收(reap)。

- 当父进程回收已终止的子进程市，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，这个时候该进程就不存在了。一个终止了但是还没有被回收的进程称为僵尸进程。

- 如果某种原因导致父进程终止了，那么内核会安排init进程成为它的孤儿进程(orphen)的养父，init进程的PID为１，系统启动时由内核创建，不会终止，是所有进程的祖先。僵尸进程即使没运行也会消耗系统内部资源，比如Exit status, various OS table

- ps打印当前正在运行的进程；waitpid函数来等待他对子进程终止或者停止

  ```C
  waitpid(pid_t pid, int *statusp, int options)
  // 当options=0时，waitpid挂起调用i就能成执行，直到它的等待集合中的一个子进程终止，返回的是导致waitpid返回的已终止子进程的PID，这个时候已终止的子进程已被回收，内核会删掉他所有的痕迹
  //等待集合是由pid确定的，如果pid>0等待集合就是一个单独的子进程，它的进程IP等于pid；如果PID=-1，那么等待集合就是由父进程所有的子进程组成的
  //若statusp参数是非空的,那么waitpid就会在statuc中放上关于导致返回的子进程的状态信息,status是statusp指向的值,子进程如有返回值,就会将返回值赋给status
  // 修改默认选项
  1. options为WNOHANG时：如果集合中的任何子进程都还没终止，那么就立即返回(返回0)。
  2. WUNTRACED：挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止，返回的PID为导致终止的子进程PID
  3. WCONTINUED：等待集合中一个正在运行的进程终止或者等大集合中一个被停止的进程收到SIGCONT信号重新开始执行
  4. 联合起来使用：WNOHANG｜WUNTRACED，立即返回，如果等待的子进程都没有被停止或终止，返回０；如果有一个停止或终止，返回这个的PID
  5. 如果调用的进程没有子进程,那么waitpid返回-1,并且设置errno为ECHILD,若是被信号中断的,那么返回-1,设置errno为EINTR
  ```

#### 加载并运行程序

使用execve函数在当前进程的上下文中加载并运行一个新程序

`int execve(const char *filename, const char *argv[], const char *envp[])`

filename为指定的可执行目标文或者scripts with begining `#!interpreter`，参数为列表argv和环境变量列表envp，只有当出现错误的时候，例如找不到filename，execve才会返回到调用程序

argv与传递main函数一样，第一个参数是filename，另外的才是真正的传递参数

envp也是如此，不过环境变量的格式必须是 "name=value"的键值对

execve函数在当前进程的上下文中加载并运行一个新的程序，它会`覆盖当前进程的地址空间`，但是没有创建一个新进程，加载的时候仍然有相同的PID，集成了所有文件描述符

### 信号

Linux信号允许进程和内核中断其他进程，一个信号就是一个消息，通知系统发生了某种类型的事件

#### 发送信号

- 内核更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送的原因可能有两个
  1. 内核检测到一个系统事件，比如除零错误或者子进程终止
  2. 一个进程调用了kill函数，显示的要求内核发送一个信号给目的进程，进程可以给自己发送信号

- Unix系统提供大量向进程发送信号的机制，所有这些机制都是基于进程组

  > 进程组：每个进程只能属于一个进程组，进程组是由一个正整数进程组ID来标识的。`getpgrp`返回当前进程的进程组
  >
  > 默认情况下，子进程和父进程同属一个进程组，进程可以使用setpgid函数来改变自己或其他进程的进程组
  >
  > 利用/bin/kill程序可以向另外的进程发送任意信号，例如`/bin/kill -9 15213`，将信号9发送给进程15213；一个为负PID会导致信号被发送到进程组PID中的每一个进程，例如`/bin/kill -9 -15213`，发送信号9给进程组15213中的每一个进程
  >
  > 从键盘发送信号：Unix使用job这个抽象的概念来表示对一条命令行求值而创建的进程，在任何时刻，至多有一个前台作业和0或多个后台作业
  >
  > 用kill函数发送信号：`int kill(pid_t pid, int sig)`，如果pid大于零，那么kill函数发送信号号码sig给进程pid，如果pid等于0，那么发送信号sig给调用进程所在的进程组中的每一个进程，包括调用进程自己。如果pid小于0，kill发送信号sig给进程组|pid|中的每一个进程
  >
  > 用alarm函数发送信号：进程通过调用alarm函数向自己发送SIGALARM信号 `unsigned int alarm(sunsigned int secs)`

#### 接收信号

当目的进程被内核强迫以某种方式对信号发送作出反应时，就接收了信号，进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号

## 虚拟内存

CPU给的地址都是虚拟地址，CPU上有一个专门的硬件MMU将`虚拟地址翻译成为物理地址`，他利用存放在主存中的查询表来动态翻译虚拟地址

#### 虚拟内存作为缓存的工具

虚拟内存被组织为一个由存放在`磁盘`上的N个连续的字节大小的单元组成的数组，每个字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上的数组的内容被缓存在主存中，同样跟其他的缓存一样需要分块。`虚拟内存的块叫做虚拟页`（按照虚拟页的方式来组织），物理内存被非为物理页，也被称为页帧。

任何时刻虚拟页有三个状态

> 1. 未分配的：VM系统还未分配或创建的页，不占磁盘空间
> 2. 缓存的：当前已缓存在物理内存中的已分配页
> 3. 未缓存的：未缓存在物理内存中的已分配页

#### DRAM Cache Orgnization

DRAM Cache在不命中的时候会有很大的penalty，因为速度太慢了，一旦不命中，要重新将数据从磁盘放到主存。

因此：

1. 虚拟也的大小一般很大，4KB或者4MB
2. 任意一个虚拟也可以映射到任意一个物理页，不像前面的缓存可能按照某个固定的规则去映射

#### Page Table

- 虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。有效位表明了该虚拟页是否被缓存在DRAM中，如果设置了有效位那么地址字段就表示DRAM中相应的物理页起始地(主存中真正的地址)，如果没有设置有效位那么空地址表示这个虚拟页还未被分配，否则就指向该虚拟也在磁盘上的起始位置

- 页表只是一个数据结构，存储在内存中，它的表项就是提供映射的规则，每一个进程都有自己的page table
- page table的每一项都是一个标志位&物理内存的地址(每一页的首地址)，这里的每一项对应的是磁盘上的虚拟页；比如PTE1里存的是，PP0的地址，那么就代表，VP1映射到了PP0。
- 缓存不命中叫做缺页(有效位没设置，但是地址不为空)，缺页会导致缺页异常，缺页异常会导致内核启动缺页异常处理程序，该程序会选择一个牺牲页(内存中)，将该牺牲页复制回磁盘(同时将原来指向这个牺牲页的页表内容也更换成磁盘的地址)，然后将磁盘上需要的数据缓存到这个位置，并修改PTE的值使它指向这个新的位置，将有效位置1。当缺页程序返回的时候，会重新启动导致缺页的指令，将该虚拟地址重新发送到地址翻译硬件，这个时候需要的内容已缓存完毕，因此可以正常读取。
- 分配页面：分配的过程起始很简单，就是在磁盘上分配对应的位置，然后让PTE的对应项指向这个位置

#### 虚拟内存作为内存管理的工具

每一个进程都有一个独立的页表，因而也就是一个独立的虚拟地址空间；不同的页表可能将多个虚拟页面映射到同一个共享物理页面上

#### 虚拟内存作为内存保护的工具

可以在也表上加上额外的许可位来控制对虚拟页面内容的访问。比如SUP READ WRITE等来控制是否能读或者写，是否是只有超级用户能够使用。 

#### 地址翻译

![image-20200727110109165](深入理解计算机系统.assets/image-20200727110109165.png)

将真实的地址看成两部分，根据前一段找到对应的页表位置，然后再查看物理地址

#### 页命中

![image-20200727110342899](深入理解计算机系统.assets/image-20200727110342899.png)

需要注意的地方：MMU会先生成PTE的地址，然后根据该地址在主存中查找对应的页表PTEA，若命中则返回对应的PTE内容(里面包含物理地址)，MMU构造出物理地址，再返回内存请求对应的数据

#### 页不命中

![image-20200727110418198](深入理解计算机系统.assets/image-20200727110418198.png)

#### Speed up the translation with a TLB

TLB是一个放在MMU里面的关于PTE的小缓存，它缓存的是PTE的表项，因此可以先查询这个缓存，如果没有再去到内存里去查询。

#### 多级页表映射

前面一个table的表项指向后面的任意一个table，每一个Level2的大小是4KB，反正是记下地址，不用真的用那么大空间

Level 1：每一个PTE指向一个page table

Level2：这里的表项指向一个页

**原理是大多数的页表都是没有用的，因此可以直接避免创建那些没有用到的页表，因为如果你只用一级，那么整个虚拟空间里面的所有页必须都要有一个表项与其对应，因此会很大。如果使用多级页表的话，第一级页表必须要能装下第二级的页表数量，但是如果第二级的很多页表都没用，那么没必要给他分配页表空间，直接用第一级的空表项就可以指明，因此节省了空间**

第一个表的表头的地址是由page table base register存储的(PTBR)

为了方便：将n-p的位进行平分，并且将每一个固定分配出来的位用来映射下一级一级表的开始，而对应位置的值则是当前级的偏置。例如，VPN1对应的每一个表项->VPN2对应的每一个表的起始地址，但是VPN1的值，则是当前VPN1所需的偏置。

#### 深入理解端到端

- 虚拟地址有可能比物理地址大，也有可能比他小，自然可能的位数也不同

  ![image-20200727141815564](深入理解计算机系统.assets/image-20200727141815564.png)

## 网络编程

- 网络基本都是基于`客户端-服务器模型`，一个应用是由一个服务器`进程`和一个或者多个`客户端进程`组成。服务器管理某种资源，并且操作这个资源为客户端提供某种服务。例如，一个Web服务器管理着一组磁盘文件，它会代表客户端进行检索和执行

- 客户端-服务器模型的基本操作是事务(transaction)

  1. 当客户端需要服务时，向服务器发送一个请求，发起一个事务
  2. 服务器接收请求后，解释它，并以适当的方式操作这个资源
  3. 服务器给客户端发送一个响应并且等待下一个请求
  4. 客户端收到响应并处理它

- 集线器：连接多个host，有很多端口，这些端口传来的数据会广播到其他端口。`集线器式的以太网`

  网桥：连接多个集线器，能够学习到信息应该忘哪个地方送，适用于更大的区域

- 在这里最重要的是，用户代码通过套接字实现系统调用，然后进行网络通信

- 客户端发起一个连接请求时，客户端的套接字端口一般是内核自动分配的，称为临时端口，而服务器端口通常是某个知名端口，和这个服务对应。比如Web服务器通常的端口是80，而电子邮件服务器使用端口25.每个知名端口的服务都有一个知名的服务名，例如Web服务的知名名字是http，email的知名名字是smtp。文件/etc/services包含一张这台机器提供的知名名字和知名端口之间的映射



















